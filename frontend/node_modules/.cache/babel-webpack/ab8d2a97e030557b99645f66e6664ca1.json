{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/diakh/M2_ACDI/Projets/Projet_Securite/Chiffrement/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { PublicKey } from \"./PublicKey\";\nimport * as bigintCryptoUtils from 'bigint-crypto-utils';\nexport class Key {\n  Key() {}\n\n  createPublicKey(upperlimit) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      let p;\n      let q;\n      let m;\n      let n;\n      let e;\n\n      do {\n        //génération aléatoire de deux grands entiers premiers p et q\n        yield bigintCryptoUtils.prime(upperlimit).then(v => {\n          p = v;\n        });\n        yield bigintCryptoUtils.prime(upperlimit).then(v => {\n          q = v;\n        }); //calcul de n\n\n        n = p * q; //calcul de m (indicatrice d'Euler) = (p - 1) * (q - 1) tel qu'il soit premier et inférieur a n\n\n        m = (p - BigInt(\"1\")) * (q - BigInt(\"1\"));\n      } while (p == q || n < m); //console.log(\"p: \" + p);\n      //console.log(\"q: \" + q);\n      //console.log(\"n: \" + n);\n      //console.log(\"m: \" + m);\n      //choix d'un petit entier impair e (exposant public) qui soit premier avec m\n\n\n      do {\n        yield bigintCryptoUtils.randBits(4).then(res => {\n          e = BigInt(res.toString());\n        });\n      } while (bigintCryptoUtils.gcd(e, m) != BigInt(1) || e % BigInt(2) == BigInt(0));\n\n      console.log(\"e : \" + e);\n      _this.publicKey = new PublicKey();\n\n      _this.publicKey.setN(n);\n\n      _this.publicKey.setE(e);\n\n      _this.publicKey.setM(m);\n\n      console.log(_this.publicKey);\n    })();\n  }\n\n  createPrivateKey(a, b) {\n    let u;\n    let n;\n    u = bigintCryptoUtils.eGcd(a, b).x;\n    console.log(u); //n = this.publicKey.getN();\n    //console.log(u.toString())\n  }\n\n}","map":{"version":3,"sources":["C:/Users/diakh/M2_ACDI/Projets/Projet_Securite/Chiffrement/frontend/src/app/Modèle/Key.ts"],"names":["PublicKey","bigintCryptoUtils","Key","createPublicKey","upperlimit","p","q","m","n","e","prime","then","v","BigInt","randBits","res","toString","gcd","console","log","publicKey","setN","setE","setM","createPrivateKey","a","b","u","eGcd","x"],"mappings":";AAAA,SAASA,SAAT,QAA0B,aAA1B;AACA,OAAO,KAAKC,iBAAZ,MAAmC,qBAAnC;AACA,OAAO,MAAMC,GAAN,CAAU;AACbA,EAAAA,GAAG,GAAG,CAAG;;AACHC,EAAAA,eAAe,CAACC,UAAD,EAAa;AAAA;;AAAA;AAC9B,UAAIC,CAAJ;AACA,UAAIC,CAAJ;AACA,UAAIC,CAAJ;AACA,UAAIC,CAAJ;AACA,UAAIC,CAAJ;;AACA,SAAG;AACC;AACA,cAAMR,iBAAiB,CAACS,KAAlB,CAAwBN,UAAxB,EAAoCO,IAApC,CAAyCC,CAAC,IAAI;AAChDP,UAAAA,CAAC,GAAGO,CAAJ;AACH,SAFK,CAAN;AAGA,cAAMX,iBAAiB,CAACS,KAAlB,CAAwBN,UAAxB,EAAoCO,IAApC,CAAyCC,CAAC,IAAI;AAChDN,UAAAA,CAAC,GAAGM,CAAJ;AACH,SAFK,CAAN,CALD,CAQC;;AACAJ,QAAAA,CAAC,GAAGH,CAAC,GAAGC,CAAR,CATD,CAUC;;AACAC,QAAAA,CAAC,GAAG,CAACF,CAAC,GAAGQ,MAAM,CAAC,GAAD,CAAX,KAAqBP,CAAC,GAAGO,MAAM,CAAC,GAAD,CAA/B,CAAJ;AACH,OAZD,QAYSR,CAAC,IAAIC,CAAL,IAAUE,CAAC,GAAGD,CAZvB,EAN8B,CAmB9B;AACA;AACA;AACA;AACA;;;AACA,SAAG;AACC,cAAMN,iBAAiB,CAACa,QAAlB,CAA2B,CAA3B,EAA8BH,IAA9B,CAAmCI,GAAG,IAAI;AAC5CN,UAAAA,CAAC,GAAGI,MAAM,CAACE,GAAG,CAACC,QAAJ,EAAD,CAAV;AACH,SAFK,CAAN;AAGH,OAJD,QAISf,iBAAiB,CAACgB,GAAlB,CAAsBR,CAAtB,EAAyBF,CAAzB,KAA+BM,MAAM,CAAC,CAAD,CAArC,IAA6CJ,CAAC,GAAGI,MAAM,CAAC,CAAD,CAAX,IAAmBA,MAAM,CAAC,CAAD,CAJ9E;;AAKAK,MAAAA,OAAO,CAACC,GAAR,CAAY,SAASV,CAArB;AACA,MAAA,KAAI,CAACW,SAAL,GAAiB,IAAIpB,SAAJ,EAAjB;;AACA,MAAA,KAAI,CAACoB,SAAL,CAAeC,IAAf,CAAoBb,CAApB;;AACA,MAAA,KAAI,CAACY,SAAL,CAAeE,IAAf,CAAoBb,CAApB;;AACA,MAAA,KAAI,CAACW,SAAL,CAAeG,IAAf,CAAoBhB,CAApB;;AACAW,MAAAA,OAAO,CAACC,GAAR,CAAY,KAAI,CAACC,SAAjB;AAlC8B;AAmCjC;;AACDI,EAAAA,gBAAgB,CAACC,CAAD,EAAIC,CAAJ,EAAO;AACnB,QAAIC,CAAJ;AACA,QAAInB,CAAJ;AACAmB,IAAAA,CAAC,GAAG1B,iBAAiB,CAAC2B,IAAlB,CAAuBH,CAAvB,EAA0BC,CAA1B,EAA6BG,CAAjC;AACAX,IAAAA,OAAO,CAACC,GAAR,CAAYQ,CAAZ,EAJmB,CAKnB;AACA;AACH;;AA7CY","sourcesContent":["import { PublicKey } from \"./PublicKey\";\r\nimport * as bigintCryptoUtils from 'bigint-crypto-utils';\r\nexport class Key {\r\n    Key() { }\r\n    async createPublicKey(upperlimit) {\r\n        let p;\r\n        let q;\r\n        let m;\r\n        let n;\r\n        let e;\r\n        do {\r\n            //génération aléatoire de deux grands entiers premiers p et q\r\n            await bigintCryptoUtils.prime(upperlimit).then(v => {\r\n                p = v;\r\n            });\r\n            await bigintCryptoUtils.prime(upperlimit).then(v => {\r\n                q = v;\r\n            });\r\n            //calcul de n\r\n            n = p * q;\r\n            //calcul de m (indicatrice d'Euler) = (p - 1) * (q - 1) tel qu'il soit premier et inférieur a n\r\n            m = (p - BigInt(\"1\")) * (q - BigInt(\"1\"));\r\n        } while (p == q || n < m);\r\n        //console.log(\"p: \" + p);\r\n        //console.log(\"q: \" + q);\r\n        //console.log(\"n: \" + n);\r\n        //console.log(\"m: \" + m);\r\n        //choix d'un petit entier impair e (exposant public) qui soit premier avec m\r\n        do {\r\n            await bigintCryptoUtils.randBits(4).then(res => {\r\n                e = BigInt(res.toString());\r\n            });\r\n        } while (bigintCryptoUtils.gcd(e, m) != BigInt(1) || (e % BigInt(2)) == BigInt(0));\r\n        console.log(\"e : \" + e);\r\n        this.publicKey = new PublicKey();\r\n        this.publicKey.setN(n);\r\n        this.publicKey.setE(e);\r\n        this.publicKey.setM(m);\r\n        console.log(this.publicKey);\r\n    }\r\n    createPrivateKey(a, b) {\r\n        let u;\r\n        let n;\r\n        u = bigintCryptoUtils.eGcd(a, b).x;\r\n        console.log(u);\r\n        //n = this.publicKey.getN();\r\n        //console.log(u.toString())\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}