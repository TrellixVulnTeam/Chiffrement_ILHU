{"ast":null,"code":"import _asyncToGenerator from \"/home/alex/Bureau/Chiffrement/Chiffrement/frontend/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { PrivateKey } from '../Modèle/PrivateKey';\nimport { PublicKey } from '../Modèle/PublicKey';\nimport * as bigintCryptoUtils from 'bigint-crypto-utils';\nimport * as i0 from \"@angular/core\";\nexport class KeyService {\n  constructor() {}\n\n  Key() {}\n\n  createPublicKey(upperlimit) {\n    return _asyncToGenerator(function* () {\n      let p;\n      let q;\n      let m;\n      let n;\n      let e;\n\n      do {\n        //génération aléatoire de deux grands entiers premiers p et q\n        yield bigintCryptoUtils.prime(upperlimit).then(v => {\n          p = v;\n        });\n        yield bigintCryptoUtils.prime(upperlimit).then(v => {\n          q = v;\n        }); //calcul de n\n\n        n = p * q; //calcul de m (indicatrice d'Euler) = (p - 1) * (q - 1) tel qu'il soit premier et inférieur a n\n\n        m = (p - BigInt(\"1\")) * (q - BigInt(\"1\"));\n      } while (p == q || n < m); //console.log(\"p: \" + p);\n      //console.log(\"q: \" + q);\n      //console.log(\"n: \" + n);\n      //console.log(\"m: \" + m);\n      //choix d'un petit entier impair e (exposant public) qui soit premier avec m\n\n\n      do {\n        yield bigintCryptoUtils.randBits(4).then(res => {\n          e = BigInt(res.toString());\n        });\n      } while (bigintCryptoUtils.gcd(e, m) != BigInt(1) || e % BigInt(2) == BigInt(0)); //console.log(\"e : \" + e);\n\n\n      let publicKey = new PublicKey();\n      publicKey.setN(n);\n      publicKey.setE(e);\n      publicKey.setM(m);\n      return publicKey;\n    })();\n  }\n\n  createPrivateKey(publicKey) {\n    let a = publicKey.getE();\n    let b = publicKey.getM();\n    let u;\n    let n;\n    let k;\n    u = bigintCryptoUtils.eGcd(a, b).x;\n    k = BigInt(-1);\n\n    while (u < BigInt(2) || u > b) {\n      u = u - k * b;\n      k -= BigInt(1);\n    }\n\n    let privateKey = new PrivateKey();\n    privateKey.setN(publicKey.getN());\n    privateKey.setU(u);\n    return privateKey;\n  }\n\n}\n\nKeyService.ɵfac = function KeyService_Factory(t) {\n  return new (t || KeyService)();\n};\n\nKeyService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: KeyService,\n  factory: KeyService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"sources":["/home/alex/Bureau/Chiffrement/Chiffrement/frontend/src/app/services/key.service.ts"],"names":["PrivateKey","PublicKey","bigintCryptoUtils","i0","KeyService","constructor","Key","createPublicKey","upperlimit","p","q","m","n","e","prime","then","v","BigInt","randBits","res","toString","gcd","publicKey","setN","setE","setM","createPrivateKey","a","getE","b","getM","u","k","eGcd","x","privateKey","getN","setU","ɵfac","KeyService_Factory","t","ɵprov","ɵɵdefineInjectable","token","factory","providedIn"],"mappings":"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","sourcesContent":["import { PrivateKey } from '../Modèle/PrivateKey';\nimport { PublicKey } from '../Modèle/PublicKey';\nimport * as bigintCryptoUtils from 'bigint-crypto-utils';\nimport * as i0 from \"@angular/core\";\nexport class KeyService {\n    constructor() { }\n    Key() { }\n    async createPublicKey(upperlimit) {\n        let p;\n        let q;\n        let m;\n        let n;\n        let e;\n        do {\n            //génération aléatoire de deux grands entiers premiers p et q\n            await bigintCryptoUtils.prime(upperlimit).then(v => {\n                p = v;\n            });\n            await bigintCryptoUtils.prime(upperlimit).then(v => {\n                q = v;\n            });\n            //calcul de n\n            n = p * q;\n            //calcul de m (indicatrice d'Euler) = (p - 1) * (q - 1) tel qu'il soit premier et inférieur a n\n            m = (p - BigInt(\"1\")) * (q - BigInt(\"1\"));\n        } while (p == q || n < m);\n        //console.log(\"p: \" + p);\n        //console.log(\"q: \" + q);\n        //console.log(\"n: \" + n);\n        //console.log(\"m: \" + m);\n        //choix d'un petit entier impair e (exposant public) qui soit premier avec m\n        do {\n            await bigintCryptoUtils.randBits(4).then(res => {\n                e = BigInt(res.toString());\n            });\n        } while (bigintCryptoUtils.gcd(e, m) != BigInt(1) || (e % BigInt(2)) == BigInt(0));\n        //console.log(\"e : \" + e);\n        let publicKey = new PublicKey();\n        publicKey.setN(n);\n        publicKey.setE(e);\n        publicKey.setM(m);\n        return publicKey;\n    }\n    createPrivateKey(publicKey) {\n        let a = publicKey.getE();\n        let b = publicKey.getM();\n        let u;\n        let n;\n        let k;\n        u = bigintCryptoUtils.eGcd(a, b).x;\n        k = BigInt(-1);\n        while (u < BigInt(2) || u > b) {\n            u = u - k * b;\n            k -= BigInt(1);\n        }\n        let privateKey = new PrivateKey();\n        privateKey.setN(publicKey.getN());\n        privateKey.setU(u);\n        return privateKey;\n    }\n}\nKeyService.ɵfac = function KeyService_Factory(t) { return new (t || KeyService)(); };\nKeyService.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: KeyService, factory: KeyService.ɵfac, providedIn: 'root' });\n"]},"metadata":{},"sourceType":"module"}